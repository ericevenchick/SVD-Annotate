# Define peripheral registers from SVD File
#@author Eric Evenchick
#@category ARM
#@keybinding 
#@menupath 
#@toolbar

# Based on SVD-Loader by Thomas Roth
# More information:
# https://leveldown.de/blog/svd-loader/
# License: GPLv3

# This modified version of SVD-Loader exists to support devices with overlapping 
# peripheral structs. Notably, the Nordic nRF5x devices.

from cmsis_svd.parser import SVDParser
from ghidra.program.model.data import UnsignedIntegerDataType, UnsignedShortDataType, ByteDataType, UnsignedLongLongDataType

class MemoryRegion:
	def __init__(self, name, start, end):
		self.name = name
		self.start = start
		self.end = end

	def length(self):
		return self.end - self.start

def reduce_memory_regions(regions):
	for i in range(len(regions)):
		r1 = regions[i]
		for j in range(len(regions)):
			r2 = regions[j]
			# Skip self
			if i == j:
				continue
			if r1.end < r2.start:
				continue
			if r2.end < r1.start:
				continue

			# We are overlapping, generate larger area and call
			# reduce_memory_regions again.
			regions[i].start = min(r1.start, r2.start)
			regions[i].end = max(r1.end, r2.end)
			regions[i].name = r1.name + "_" + r2.name
			regions.remove(regions[j])
			return reduce_memory_regions(regions)
	return regions

def calculate_peripheral_size(peripheral, default_register_size):
	size = 0
	for register in peripheral.registers:
		register_size = default_register_size if not register._size else register._size
		size = max(size, register.address_offset + register_size/8)
	return size


svd_file = askFile("Choose SVD file", "Load SVD File")

print("Loading SVD file...")
parser = SVDParser.for_xml_file(str(svd_file))
print("\tDone!")

# CM0, CM4, etc
cpu_type = parser.get_device().cpu.name
# little/big
cpu_endian = parser.get_device().cpu.endian
# default size is device word size
default_register_size = parser.get_device().size

# Not all SVDs contain these fields
if cpu_type and not cpu_type.startswith("CM"):
	print("Currently only Cortex-M CPUs are supported.")
	print("Supplied CPU type was: " + cpu_type)
	sys.exit(1)

if cpu_endian and cpu_endian != "little":
	print("Currently only little endian CPUs are supported.")
	print("Supplied CPU endian was: " + cpu_endian)
	sys.exit(1)

peripherals = parser.get_device().peripherals

print("Generating memory regions...")
# First, we need to generate a list of memory regions.
# This is because some SVD files have overlapping peripherals...
memory_regions = []
for peripheral in peripherals:
	start = peripheral.base_address
	length = peripheral.address_block.offset + peripheral.address_block.size
	end = peripheral.base_address + length

	memory_regions.append(MemoryRegion(peripheral.name, start, end))

# merge any overlapping memory regions
memory_regions = reduce_memory_regions(memory_regions)

# Create memory blocks:
for r in memory_regions:
	try:
		block = createMemoryBlock(r.name, toAddr(r.start), None, r.length(), False)
		block.setRead(True)
		block.setWrite(True)
		block.setExecute(False)
		block.setVolatile(True)
		block.setComment("Generated by SVD-Loader.")
	except Exception as e:
		print("\tFailed to generate memory block for: " + r.name)
		print("\t", e)

print("\tDone!")

print("Generating peripherals...")
for peripheral in peripherals:
	print("\t" + peripheral.name)

	if(len(peripheral.registers) == 0):
		print("\t\tNo registers.")
		continue

	createLabel(toAddr(peripheral.base_address), peripheral.name, False)

	for register in peripheral.registers:
		register_size = default_register_size if not register._size else register._size

		r_type = UnsignedIntegerDataType()
		rs = register_size / 8
		if rs == 1:
			r_type = ByteDataType()
		elif rs == 2:
			r_type = UnsignedShortDataType()
		elif rs == 8:
			r_type = UnsignedLongLongDataType()

		addr = toAddr(register.address_offset + peripheral.base_address)
		createData(addr, r_type)
		createLabel(addr, "%s.%s" % (peripheral.name, register.name), True)
		setEOLComment(addr, register.description)
